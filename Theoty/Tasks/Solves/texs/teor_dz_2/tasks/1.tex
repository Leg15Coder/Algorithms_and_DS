\section{Задача 1 (Вдвое больший справа)}
\subsection{Идея решения}
Создаём массив (B[1:n]) пар вида \{ A[i], i \}. Отсортируем этот массив в обратном порядке и по отсортированному массиву будем последовательно брать элементы, добавляя их в очередь обработки (inProcess), при выходе из которой их индексы будут добавляться в декартовое дерево (possibleIndexes).

\subsection{Алгоритм}

\begin{itemize}

    \item Общий алгоритм
    \begin{enumerate}
        \item Создаём описанные выше структуры: B, inProcess, possibleIndexes
        \item Заполняем массив B парами: B[i] $=$ \{ A[i], i \}
        \item Сортируем B по убыванию любой сортировкой, асимптотика которой не хуже O(NlogN), например, MergeSort
        \item Для каждого элемента current из B выполняем пункты 5-8:
        \item Пока крайний элемент очереди (firstInQueue) не меньше, чем current[1] * 2, удаляем из очереди крайний элемент и добавляем в possibleIndexes значение firstInQueue[2]
        \item Если possibleIndexes пустая, то ответом для элемента A[current[2]] будет None
        \item Иначе ответом для A[current[2]] будет possibleIndexes.next(current[2])
        \item Добавляем в inProcess текущий элемент (current)
    \end{enumerate}

    \item Реализация possibleIndexes::next(value)
    \begin{enumerate}
        \item Заводим переменную result $=$ None
        \item Начинаем обходить ДД, начиная с корня (текущую вершину обозначим за node):
        \item Если node $\neq$ None выполняем шаги 4-5
        \item Если значение в текущей вершине больше value, то result = min(result, node.value) и переходим в левого ребёнка node
        \item иначе переходим в правого ребёнка node
        \item В качестве ответа возвращаем result
        \item Примечание: None является нейтральным элементом по операции min, то есть min между None и любым другим другим значением равно другому значению
    \end{enumerate}
\end{itemize}

\subsection{Краткое объяснение решения}
Так как мы обрабатываем значения в порядке убывания, и все обработанные значения хотя бы в 2 раза больше элемента, для которого считаем ответ, то если для этого элемента есть ответ, то он находится среди индексов обработанных значений, так как любые другие значения не подходят под условие. Именно для этого мы и храним индексы в куче, для быстрого поиска ближайшего справа среди всех доступных.

\subsection{Асимптотика}
Создание массива B занимает O(N), а его сортировка O(NlogN). Дальше каждый элемент B обрабатывается в очереди не больше чем 2 раза: при добавлении и удалении, то есть за O(1), а ответ для него считается за O(logN), так как используется функция possibleIndexes::next. То есть, несмотря на то, что за одну итерацию из очереди может удалится до N элементов, суммарно за все итерации удалится не более N элементов. Постобработка удалённого из очереди элемента занимает O(logN) (добавление в ДД). Итоговая асимптотика по времени получается O(N + NlogN + N($1^*logN$ + logN + 1)) $=$ O(NlogN).

Каждая из структур B, possibleIndexes и inProcess содержат в моменте не более N элементов, то есть асимптотика решения по памяти O(N).

