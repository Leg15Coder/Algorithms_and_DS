\section{Задача 3 (Параллельный поиск)}
\subsection{Идея решения}
Отсортируем запросы $k_i$ по возрастанию, рекурсивно, начиная со среднего элемнта, будем сортировать через quickSort ключи так, чтобы на $a_{k_i}$ месте был ответ на $k_i$ запрос.

\subsection{Алгоритм}
\begin{itemize}
    \item Функция \textbf{findOrders}(a[], k[], left, right)\\\\
    Принимает на вход a[] и уже отсортированный массив k[], возращает массив ans[], где ${ans}_i$ - ответ на $k_i$ запрос. left и right - соответственно левая и правая граница подмассива массива k[], который сейчас обрабатывается
    \begin{enumerate}
        \item Если left $==$ right, ничего не делаем, иначе:
        \item current $=$ $k_{\frac{left + right}{2}}$ - какую порядковую статистику ищем
        \item ${ans}_{\frac{left + right}{2}}$ $=$ quickSelect(a[left:right], current - left)
        \item Рекурсивно вызываем findOrders(a[left:current], k[], left, current) и findOrders(a[current+1:right], k[], current, right)
    \end{enumerate}

    \item Функция \textbf{quickSelect}\\\\
    Принимает на вход a[] и некоторый $k_i$, возвращает $k_i$-ю порядковую статистику a[]
    \begin{enumerate}
        \item Берём случайный элемент из a[] (обозначим его pivot) и перенесём его в конец массива
        \item Заведём счётчик-указатель на индекс leftPartEnd $=$ 1
        \item Для каждого элемента из a[] сравним его со значением pivot
        \item Если он меньше либо равен, поменяем его местами с элементом с индексом leftPartEnd и увеличим leftPartEnd на 1
        \item Если по итогу обхода всех элементов leftPartEnd оказался равен $k_i$, возвращаем значение pivot
        \item Если leftPartEnd < $k_i$, то рекурсиво ищем порядковую статистику справа от pivot: return quickSelect(a[leftPartEnd+1:], $k_i$ - leftPartEnd)
        \item Если leftPartEnd > $k_i$, то рекурсиво ищем порядковую статистику слева от pivot: return quickSelect(a[:leftPartEnd], $k_i$)
    \end{enumerate}

    \item \textbf{Основной алгоритм}
    \begin{enumerate}
        \item Сортируем k[] любой сортировкой с асимптотикой не хуже O(NlogN) (Например, с помощью quickSort)
        \item ans[] $=$ findOrders(a[], k[], 0, |k|) - массив ответов на все запросы
        \item Примечание: Если требуется отвечать на запросы последовательно в исходном порядке, то можно создать вспомогательный массив соответствий старый индекс-новый индекс на моменте сортировки k[]. На итоговую асимптотику это не повлияет
    \end{enumerate}

    \item \textit{Подразумевается что в функцию и из функции всегда передаются ссылки так, как это происходит в Java}
\end{itemize}

\subsection{Обоснование решения}
quickSelect делит исходный массив на две части: меньше k-й порядковой и больше
неё. Следовательно для любого i < k i-я порядковая будет лежать в первой части, а для i > k - во второй части, поэтому их можно рассматривать отдельно и независимо, что собственно и делает findOrders. 

leftPartEnd указывает на pivot, так как pivot будет последним подходящим под условие в пункте 4 элементом, потому что стоит в конце рассматриваемой части массива.

\subsection{Асимптотика}
k[] сортируется за O(MlogM)

quickSelect без учёта рекурсии работает за O(N), а в рекурсию передаётся не весь массив, а только часть, которая в среднем равна $\frac{N}{2}$. То есть, асимптотика quickSelect равна $$O(\sum_{i-0}^{...}(\frac{N}{2^i})) = O(N)$$

Теперь разберёмся с findOrders. При каждом вызове findOrders, она единожды вызывает quickSelect, а потом дважды рекуррентно себя, но от двух независимых частей массива a[]. То есть каждый следующий "уровень" рекурсии работает всреднем с массивом длиной $\frac{N}{2}$, где N - средняя длина массива на предыдущем "уровне". Несложно заметить, что уровней всего ${log}_2M$. Откуда получаем асимптотику findOrders: $$\sum_{i=0}^{{log}_2M}2^i*qs(\frac{N}{2^i}) = O(NlogM)$$где qs(N) - асимптотическая сложность по времени функции quickSelect при передаче в неё массива длиной N.


\underline{Итоговая асимптотика}: O(MlogM + NlogM) $=$ O(NlogM), так как по условию M $\leq$ N
