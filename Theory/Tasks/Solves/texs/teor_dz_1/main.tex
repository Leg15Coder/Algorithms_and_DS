\documentclass[a4paper,14pt]{article}
\input{etc/preamble}

\title{Теоретическое задание №1}
\author{Дмитрий Ряжских}
\date{Октябрь 2024}
\newpage
\begin{document}
\begin{titlepage}
	\clearpage\thispagestyle{empty}
	\centering
	\vspace{0.5ex}
	
	\textbf{Теоретическое домашнее задание \\ по алгоритмам и структурам данных \\ Задание №1}
	\vspace{20ex}
	\vspace{13ex}
	
	\vspace{1ex}
	Автор: \href{https://t.me/dimka_ryaz}{\textit{Ряжских Дмитрий}}\\

	\vfill
	   МФТИ 2024 
	\pagebreak
	
\end{titlepage}

\section{Задача 1 (Зацикленный)}
\subsection{Описание алгоритма}
Для решения этой задачи можно использовать следующим алгоритмом:

\begin{enumerate}
    \item\textbf{Обнаружение цикла.}
\begin{itemize}
    \item Заведём два указателя
    \item Изначально оба указателя указывают на начало списка
    \item За одну итерацию алгоритма первый указатель двигается на 1 элемент, а второй на 2
    \item Второй указатель обрабатывает каждый узел списка (т.е. он не может "перепрыгнуть" первый указатель)
    \item Если в списке нет цикла, то алгоритм завершится, когда второй указатель достигнет конца списка ("уткнётся" в null или EndNode). В этом случае количество шагов, будет равно количеству узлов в списке, то есть O(n)
    \item Если в списке есть цикл, указатели в конечном итоге всё равно встретятся. Это произойдет в худшем случае за n шагов, потому что на каждом шаге разница между ними уменьшается на один при движении по циклу
\end{itemize}

Таким образом асимптотика поиска цикла O(n)

    \item\textbf{Определение длины цикла.}
    
Если цикл обнаружен, зафиксируем позицию второго указателя и продолжим двигать первый указатель на один шаг, подсчитывая количество шагов до тех пор, пока он снова не встретится с зафиксированным указателем. Это количество шагов будет длиной цикла. Максимум потребуется n итераций, значит, асимптотика O(n) по времени.

    \item\textbf{Определение узла входа в цикл.}

Узлом из цикла будет тот, на который указывает второй указатель. Асимптотика O(1) по времени.
\end{enumerate}

\subsection{Итог}

Таким образом, алгоритм работает за линейное время O(n), так как все его этапы (определение наличия цикла, поиск узла цикла и определение длины цикла) выполняются за линейное количество шагов. Алгоритм использует только несколько указателей и не требует дополнительной памяти, пропорциональной размеру списка, поэтому его пространственная сложность — O(1).

\section{Задача 2 (Палкой по гоблину)}
\subsection{Описание алгоритма}
Для решения этой задачи можно использовать алгоритм бинарного поиска по числу ударов, необходимых для уничтожения всех гоблинов. Основная идея заключается в том, чтобы проверить, возможно ли уничтожить всех гоблинов за k ударов и использовать бинпоиск для определения минимального k, при котором это возможно.


\begin{enumerate}
    \item\textbf{Описание бинпоиска.}
    \begin{itemize}
        \item Минимальное число ударов (left), которое понадобится, — это 0
        \item Максимальное число ударов (right) можно установить как $\lceil\frac{\max{h_i}}{\max{(p, q)}}\rceil$, где $\max{h_i}$ — максимальное здоровье среди всех гоблинов, чтобы гарантировать, что мы можем перебить самого сильного гоблина
        \item Определим функцию проверки (только ради краткости записи назовём её f), которая проверяет, можно ли перебить всех гоблинов за k ударов
        \item Пока разница между right и left больше 1 Повторяем все следующие шаги:
        \item $mid = \frac{left + right}{2}$
        \item Если f(k) возвращает true, значит k ударов достаточно, и right устанавливаем равным mid
        \item Если f(k) возвращает false, значит k ударов недостаточно, и left устанавливаем равным mid
    \end{itemize}

    \item\textbf{Описание функции f.}
    \subsubsection{ Если p > q }
    \begin{itemize}
        \item Заводим счётчик count\_headshots = 0
        \item Для каждого гоблина считаем можно ли его убить только ударами, при которых на него не направляется посох. $remains\_hp_i = h_i$ - q * k
        \item Если $remains\_hp_i$ > 0, то считаем сколько ударов посохом по нему нужно нанести, чтобы убить. $count\_headshots \mathrel{+}= \lceil\frac{remains\_hp_i}{p - q}\rceil$
        \item Если после итерации по всем гоблинам count\_headshots > k, то нельзя всех убить за k выстрелов, следовательно f вернёт false, в противном случае - true
    \end{itemize}

    \subsubsection{ Если p $\leq$ q }
    \begin{itemize}
        \item Заводим счётчик count\_headshots = k
        \item Для каждого гоблина считаем можно ли его убить только ударами, при которых на него не направляется посох. $remains\_hp_i = h_i$ - q * k
        \item Если $remains\_hp_i$ > 0, то сразу возвращаем false - сменив пассивный удар на прицеленный здоровье уже не уменьшится
        \item Если $remains\_hp_i$ < 0 и p < q, попробуем заменить пассивные удары на активные, оставив гоблина мёртвым. $count\_headshots \mathrel{-}= \lfloor\frac{|remains\_hp_i|}{q - p}\rfloor$
        \item Если после итерации по всем гоблинам count\_headshots > 0 и при этом p < q, то нельзя всех убить за k выстрелов, следовательно f вернёт false, в противном случае - true
    \end{itemize}
    \end{enumerate}

    \subsection{Оценка сложности.}
    Количество итераций бинарного поиска — это $O(log(right - left)) = O(log(right))$ (т.к. $left = 0) = O(log\lceil\frac{\max{h_i}}{\max{(p, q)}}\rceil) = O(log(\max{h_i}))$ (т.к. p и q константы)

    Для каждого значения k, которое проверяется в процессе бинарного поиска, нам нужно пройтись по всем N гоблинам и проверить, достаточно ли k ударов, чтобы здоровье каждого из них стало меньше или равно нулю. Это занимает O(N) операций для каждого шага бинарного поиска

    Итак, каждая проверка за O(N) выполняется за $O(log(\max{h_i}))$ итераций бинарного поиска. Следовательно, общая временная сложность будет: $O(Nlog(\max{h_i}))$

\section{Задача 3 (Прибавляй, арифметизируй!)}
\subsection{Описание алгоритма}
Заведём два дополнительных массива для хранения разности прогрессии (diff[N+1]) и начала прогрессии (delta[N+1]). После каждого запроса будем их обновлять, а в конце пересчитаем все элементы исходного массива, опираясь на дополнительные, и выведем его.

\begin{enumerate}
    \item\textbf{Описание обработки запроса.}

    \begin{itemize}
        \item Добавляем b в $delta[l]$, чтобы обозначить начало прогрессии
        \item Добавляем d в $diff[l]$, чтобы прогрессия начала нарастать с l
        \item В $delta[r + 1]$ вычитаем  $b + (r - l) * d$, чтобы погасить действие прогрессии после r
        \item В $diff[r + 1]$ вычитаем d, чтобы убрать наращивание после r.
    \end{itemize}

    \item\textbf{Описание конечного подсчёта.}
    (Накопление изменений) После обработки всех запросов нужно накопить значения в исходном массиве, используя $delta$ и $diff$. Для этого:

    \begin{itemize}
        \item Заведём накопительные переменную $cur\_delta = 0$ и $cur\_diff = 0$
        \item Проходим по массиву и накапливаем значения $cur\_delta \mathrel{+}= delta[i]$ $cur\_diff \mathrel{+}= diff[i]$
        \item Обновляем элементы списка: $a[i] \mathrel{+}= cur\_delta$
        \item Обновляем текущую разность $cur\_delta \mathrel{+}= cur\_diff$
    \end{itemize}

    Теперь осталось вывести обновлённый исходный массив.

    \subsection{Оценка сложности.}
    Каждый запрос выполняется за O(1), следовательно все запросы выполнятся за O(Q). Обновление значений в конце происходит за O(N) т.к. на обработку каждого элемента уходит O(1). Таким образом, итоговая временная сложность O(Q + N)

    Алгоритм использует O(N) дополнительной памяти, т.к. все вспомогательные массивы $\approx$ такой же длины как исходный, а количество дополнительных массивов константное.

\end{enumerate}

\section{Задача 4 (В поисках сдвига)}
\subsection{Описание алгоритма}
\subsubsection{Часть 1 (Элементы различны)}
Для поиска k за O(logN), можно использовать бинарный поиск

\begin{itemize}
    \item Установим два указателя: $left = 0$ и $right = N-1$.
    \item Пока $left < right$ Вычислим средний индекс $mid = \lfloor\frac{left + right}{2}\rfloor$.
    \item Если  $a[mid] > a[right]$, это значит, что $mid$ находится в неотсортированной части массива, поэтому точка разрыва должна быть справа от $mid$, то есть $left = mid+1$.
    \item Иначе это значит, что правая часть от $mid$ до $right$ отсортирована, и точка разрыва должна быть слева от $mid$, точка разрыва находится в левой части или на $mid$, поэтому $right = mid$.
    \item После завершения цикла $left$ указывает на индекс минимального элемента, а количество сдвигов$ k = left$.
\end{itemize}
Логарифмическая сложность достигается, поскольку на каждой итерации размер рассматриваемого диапазона уменьшается вдвое.

\subsubsection{Часть 2 (Некоторые элементы неразличимы)}
Рассмотрим массив, в котором все элементы одинаковы, например, $a = [1,1,... ,1]$. Здесь невозможно определить место разрыва, так как массив выглядит одинаково независимо от числа сдвигов k. Чтобы определить k, необходимо в худшем случае проверить все элементы, что требует $O(n)$ операций.
Поэтому нижняя оценка времени выполнения любого алгоритма для поиска k в массиве с возможными одинаковыми элементами — это $\Omega(n)$.

\section{Задача 5 (В поисках подогорода)}
\subsection{Описание алгоритма}
\subsubsection{массив высот}
Построим массив высот (height[N][M], где N $\times$ M - размер огорода), который будет представлять количество подряд идущих строк с помидорами, начиная с текущей строки. Начнем с первой строки и будем обновлять height для каждой следующей строки, как в гистограмме 
$$
\left\{
\begin{aligned}
& heights[i][j] = garden[i][j],\quad i = 0\\
& heights[i][j] = heights[i - 1][j] + 1 \quad if \quad garden[i][j] = 1 \quad else \quad 0,\quad i \neq 0 
\end{aligned}
\right.
$$
Где garden - массив, представляющий огород из условия, в котором 1 - сектор с помидором, а 0 - сектор с огурцами.

\subsubsection{подсчёт ответа}
Теперь для каждой строки определим максимальный прямоугольник (таковым будем считать прямоугольник с наибольшей площадью), нижняя  сторона которого лежит на этой строке.

\begin{itemize}
    \item Инициализируем пустой стек
    \item Пока стек не пуст и текущая высота меньше или равна высоте элемента на вершине стека, забираем элемент из стека и вычисляем площадь прямоугольника с высотой равной высоте удаленного элемента
    \item Если стек пуст, ширина равна текущему индексу, иначе ширина равна разнице между текущим индексом и индексом элемента на вершине стека минус один
    \item Берём максимум из имеющегося ответа и полученным при итерации
    \item Помещаем текущий индекс в стек
    \item После того как прошли все элементы строки, обрабатываем оставшиеся элементы в стеке аналогичным образом
\end{itemize}

\subsection{Итог}
Проход по каждой строке занимает O(M), а обработка стека также выполняется за O(M), так как каждый элемент обрабатывается максимум дважды. Строк N, следовательно алгоритм работает за O(N*M) по времени и за O(N*M) дополнительной памяти.

\section{Задача 6 (Деамортизация)}
\subsection{Описание алгоритма}
Заведём три выделенных участка памяти (статических массива) длины N/2, N и 2N
и назовём их previous, current и next соответственно и три указателя которые будут работать в соответствующих массивах: prev, cur, nxt.

\begin{itemize}
    \item get - элементы динамического массива в i-й позиции считываются из current
    \item push - при добавлении элемента cur сдвигается на 1 вправо и записывает новый элемент в ячейку памяти на которую указывает. nxt сдвигается на 2 вправо, записывая в посещённые ячейки значения из ячеек массива current, стоящие в местах 2*(cur-N/2) и 2*(cur-N/2) + 1
    \item pop - при удалении элемента prev сдвигается на 1 вправо, записывая в посещённую ячейку значение из ячейки массива current, стоящее на месте (N-cur), после чего cur сдвигается на 1 влево
    \item allocate - когда cur$ = $N-1 и вызывается add происходят следующие действия при непосредственным вызовом add: next становится current, бывший current становится previous, а бывший previous удаляется. Новое N равно старому удвоенному, а next - новый участок выделенной памяти длины 2 новых N
    \item deallocate - когда cur = N/2 - 1 и вызывается pop аналогично allocate: previous -> new MemoryBlock(N), current -> previous, next -> current, N -> N/2; delete old\_next
\end{itemize}

\subsection{Почему это работает}
Чтобы подготовиться к будущему увеличению размера, указатель nxt сдвигается на 2 вправо, и значения из массива current копируются в массив next в удвоенные индексы. Таким образом, при заполнении массива current массив next будет уже заполнен половиной элементов, соответственно равных current

При удалении элемента указатель prev сдвигается вправо, чтобы показать на следующую позицию. Значение из массива current копируется в массив previous, что позволяет подготовиться к возможному уменьшению размера

Перекопирование происходит постепенно, по мере добавления элементов, так что в каждый момент времени выполняется только постоянное количество операций, чтобы поддерживать три массива


\subsection{Оценка сложности}
Подготовка массивов next и previous позволяет избежать больших затрат при увеличении размера. Так как перекопирование выполняется по частям, чистая стоимость каждой операции остается O(1).

В любой момент времени объем выделенной памяти ограничен сверху 3N, так как previous, current, и next имеют размеры N/2, N, и 2N соответственно. При этом размер массива size всегда близок к N, что дает $capacity = \Theta(size)$. При увеличении и уменьшении размера массива поддерживается баланс между количеством элементов и выделенной памятью, так что нет перерасхода памяти.


\section{Задача 7 ( k-ичная куча куч)}
\subsection{формулы индексов}
Индекс i-го ребенка j-го узла:
Если мы используем нумерацию узлов начиная с 0, то для k-ичной кучи, где каждый узел имеет максимум k детей, индексы детей j-го узла вычисляются по следующей формуле:
$$
Индекс i-го ребенка узла j = k * j + i + 1
$$
где i$ = $0, 1, ..., k-1. Это предполагает, что дети каждого узла идут подряд после родителя.
$$
Индекс родителя узла i = \frac{i - 1}{k}
$$
(Здесь предполагается целочисленное деление)

\subsection{оценка времени просеивания}
При просеивании вниз в k-ичной куче узел сравнивается с k своими детьми на каждом уровне, чтобы найти минимального (или максимального, в зависимости от типа кучи). Поскольку глубина кучи составляет $\log_k{N}$ (где N — количество элементов в куче), время работы будет: O(k*logN)

При просеивании вверх узел поднимается по уровням кучи, сравниваясь с родителем на каждом уровне. Глубина кучи составляет $\log_k{N}$, поэтому время работы: O(logN)

\subsection{оценка времени просеивания если дети в куче}
Если k детей каждого узла организованы в виде бинарной кучи, то операции сравнения и поиска минимального (или максимального) среди детей занимают O(logk).

Просеивание вниз:
На каждом уровне требуется O(logk) времени, чтобы найти минимального среди k детей. Поскольку глубина кучи равна $\log_k{N}$, итоговая сложность будет: O(logk*logN) = O(logN), т.к. k - заданная константа

Просеивание вверх:
Это не изменяется, так как при просеивании вверх мы все равно сравниваем элемент только с его родителем, и время работы остается: O(logN)

Таким образом, использование бинарной кучи для хранения детей увеличивает время работы просеивания вниз, но просеивание вверх остается неизменным.

\section{PS}
Все задачи решались основываясь на том, что мы знаем асимптотику решения 'тривиального вида задачи', такого как 'обычный' бинпоиск или 'обычная' куча. Её же мы доказывали на лекции, а фактами с лекций по условию задания можно пользоваться бездоказательно. 

\end{document}
